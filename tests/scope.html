<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/javascript" src="../js/decl.js"></script>
    <script type="text/javascript" src="../js/decl/expression.js"></script>
    <script type="text/javascript" src="data.js"></script>
    <link rel="stylesheet" href="list.css">
    <title>compile me, link me, be happy!</title>
    <style>
        *[template] {
            opacity: .33;
        }
        h2 {
            margin: 16px 0 8px 0;
            border-bottom: 2px solid #888;
            background: #DDD;
        }
    </style>
</head>
<body decl2>

    <h2>DOM traversing: {{ document.title }}</h2>
    <ul>
        <li>Current URL: {{ document.URL }} (last modified: {{ document.lastModified }})</li>
    </ul>

    <ul scope="foo" class="list">
        <li repeat="city in cities">
            <div class="icon" style="background-image: url(images/{{city.type}}.png)"></div>
            <span class="name">City #{{city.country}}</span>
            <span class="desc">Tags: <a class="tag" repeat="tag in city.tags" href="/tags/{{ tag }}">{{ tag }}</a></span>
            <span class="dist">{{city.distance}} mi</span>
        </li>
    </ul>
    <div scope="foo">Credits goes to: {{ ['Foo', 'Bar', 'Nix'] | join(" / ") }}, current time: {{ time() | date }}</div>
    <div>dd.MM.yyyy - {{ time() | date("dd.MM.yyyy")}}</div>
    <div>ddd MMMM d yy - {{ time() | date("ddd MMMM d yy")}}</div>
    <div>hh:mm:ss.zzz - {{ time() | date("hh:mm:ss.zzz")}}</div>
    <div>h:m:s ap - {{ time() | date("h:m:s ap")}}</div>
</body>
<script>
    window.time = function() {
        if (this.update) setInterval(this.update, 1000);
        return +new Date();
    };
</script>
<script>
var modules = [];

// prevents SCRIPT traverse
modules.push(function(node, next) {
    if ("SCRIPT" === node.nodeName) {
        console.log("~ [noScript] prevents compiling of script node", node);
        return;
    }
    next();
});

// proceed repeat
modules.push(function(node, next) {
    if (node.hasAttribute("repeat")) {
        var match = node.getAttribute("repeat").match(/^(\w*) in (.*)$/);
        node.removeAttribute("repeat");
        console.log("~ [repeat]", match);

        if (!match || match.length !== 3) {
            throw new Error("repeat needs 'x in y'");
        }

        var iterator = match[1]
          , dataSet = match[2]
          , linker = compile(node)
          ;


        dataSet = decl._prepareArray(dataSet);

        return function(n, scope) {
            // prepare iteration
            var data = decl.solve(scope, dataSet);
            data = decl._prepareArray(data);
            var parentNode = n.parentNode;
            parentNode.removeChild(n);

            for ( var i = 0, l = data.length; i < l; i++) {
                var clone = node.cloneNode(true);
                var cloneScope = decl.scope(scope);
                cloneScope[iterator] = data[i];
                console.log("~ [repeat.linker]", data[i], "from", data, "as", iterator, "=", cloneScope, scope);
                linker(clone, cloneScope);
                parentNode.appendChild(clone);
            }

            data.$on("add", function(item) {
                var clone = node.cloneNode(true);
                var cloneScope = decl.scope(scope);
                cloneScope[iterator] = item;
                linker(clone, cloneScope);
                parentNode.appendChild(clone);
            });

            data.$on("remove", function(item, idx) {
                var node = parentNode.children[idx];
                parentNode.removeChild(node);
            });

        };
    } else {
        next();
    }
});
/*
// fill #test nodes
modules.push(function(node, next) {
    next();
    if (1 === node.nodeType && "SPAN" === node.nodeName) {
        return function(node) {
            node.innerText = "*" + node.innerText + "*";
        };
    }
});
*/
// proceed {{ expressions }}
modules.push(function(node, next) {
    function decode(str) {
         return str && unescape(str.replace(/\+/g, " "));
    }
    if (0 === node.children.length) {
        var rx = /{{(.*?)}}/g
          , text = node.innerText
          , isText = undefined !== text && rx.test(text)
          , textPieces = undefined !== text && text.split(rx).map(function(piece, i) { return i%2 ? new Expression(piece) : piece })
          , href = node.href && decode(node.href)
          , isHref = undefined !== href && rx.test(href)
          , style = node.style.cssText && decode(node.style.cssText)
          , proceedStyle = undefined !== style && rx.test(style)
          ;
          console.log("~ compile.expr", node, style, textPieces);
        if (isText || isHref || proceedStyle) {
            return function(node, scope) {
                if (isText) {
                    var text = textPieces.slice();
                    textPieces.forEach(function(piece, i) {
                        if (piece instanceof Function) piece(scope, function(value) {
                            text[i] = value;
                            node.innerHTML = text.join("");
                        });
                    });
//                    node.innerHTML = textPieces.map(function(piece) { return piece instanceof Function ? piece(scope) : piece }).join("");
//                    node.innerHTML = text.replace(rx, function(all, match) {
//                        return "<i>" + decl.solve(scope, match.trim()) + "</i>";
//                    });
                }
                if (isHref) {
                    node.href = href.replace(rx, function(all, match) {
                        return decl.solve(scope, match.trim());
                    });
                }
                if (proceedStyle) {
                    node.style.cssText = style.replace(rx, function(all, match) {
                        return decl.solve(scope, match.trim());
                    });
                }
            };
        }
    } else {
        next();
    }
});

// traverser
function traverser(node, path, linker) {
        var nodes = [];
        for (var i = node.children.length >>> 0; i--;) nodes[i] = node.children[i];
        for (i = 0; (node = nodes[i]); i++ ) {
            __compile(node, path.concat([i]), linker);
        }
};

function __compile(node, path, linker) {
    var i = 0
      , module
      , fun
      ;

    function f() {
        if ((module = modules[i++])) {
            fun = module(node, function(fun) {
                if (fun) linker(path, fun);
                f();
            });
            if (fun) linker(path, fun);
        } else {
            traverser(node, path, linker);
        }
    }
    f();
}

function compile(node) {
    console.log("~ compile", node);
    var links = [];

    __compile(node, [], function(path, fun) {
        console.log("~ linker.reg", path);
        links.push([path, fun]);
    });

    // link function
    return function(node, scope) {
        scope = scope || window;
        console.log("~ linker", node, scope, links);
        for (var i=0, link; (link=links[i]); i++) {
            var target = node;
            for (var j=0, l=link[0].length; j<l; j++) {
                target = target.children[link[0][j]];
            }
            link[1](target, scope);
        }
    };

};

compile(document.body)(document.body);
</script>
</html>
