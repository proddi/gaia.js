<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/javascript" src="../js/decl.js"></script>
    <script type="text/javascript" src="data.js"></script>
    <link rel="stylesheet" href="list.css">
	<title>parse me, link me, be happy!</title>
</head>
<body>

</body>
<script>
// expression | filter | filter(expression)

var ExecutedExpression = function(expression, fun, filters) {
    this.expression = expression;
}
ExecutedExpression.prototype.update = function() {
}

var Expression = function(s) {
    this.s = s;
    this.bindings = [];

    var fun = this.parseExpression()
           || function(scope, value) { return "Unknown expression: " + s; }

    var filters = [],
        filter;
    while (filter = this.parseFilter()) filters.push(filter);

    if (this.s) console.warn("~ Couldn't parse complete expression:", this.s);
    function evaluate(scope) {
        var value = fun.call(this, scope, undefined);
        for (var i=0, l=filters.length; i<l; i++) {
            value = filters[i].call(this, value);
        }
        return value;
    };
    
    var expr = this;
    return function(scope, update) {
        if (!update) return evaluate.call({}, scope);
        var ctx = new ExecutedExpression(expr);
        ctx.update = function() {
        
//                console.log("scope.update", scope);
            update(evaluate.call({}, scope));
        };
        update(evaluate.call(ctx, scope));
        return ctx;
    };
};

Expression.prototype.isChar = function(c) {
    if (c === this.s.charAt(0)) {
        this.s = this.s.substr(1);
        return true;
    }
}

Expression.prototype.parseExpression = function() {
    this.s = this.s.trim();
    return (this.parseFunction()
            || this.parseObjectPath()
            || this.parseNumber()
            || this.parseString());
}

Expression.prototype.parseNumber = function() {
    var match = /^([\d]+)/.exec(this.s);
    if (match) {
        this.s = this.s.substr(match[0].length);
        var value = parseFloat(match[1]);
        return function(scope, prev) {
            console.log("~ parseNumber", this, scope, prev);
            return value;
        }
    }
};

Expression.prototype.parseString = function() {
    var match = /"(.*?)"/.exec(this.s); // needs to be improved
    if (match) {
        this.s = this.s.substr(match[0].length);
        var value = match[1];
        return function(scope, prev) {
            return value;
        }
    }
    var match = /'(.*?)'/.exec(this.s); // needs to be improved
    if (match) {
        this.s = this.s.substr(match[0].length);
        var value = match[1];
        return function(scope, prev) {
//            console.log("~ string:", scope);
            return value;
        }
    }
};

Expression.prototype.parseObjectPath = function() {
    var match = /^([A-Z-a-z_][\w\.]*)/.exec(this.s);
    if (match) {
        this.s = this.s.substr(match[0].length);
        var pieces = match[1].split(".");
        this.bindings.push(pieces);
        return function(scope, prev) {
            for (var i=0, l=pieces.length; i<l; i++) scope = scope[pieces[i]];
            return scope;
        }
    }
};

Expression.prototype.parseFunction = function() {
    var match = /^([A-Z-a-z_][\w\.]*)\(/.exec(this.s);
    if (match) {
        this.s = this.s.substr(match[0].length);
        var fun = match[1],
            params = [];
        if (!this.isChar(")")) {
            do {
                params.push(this.parseExpression());
            } while (this.isChar(","));
            if (!this.isChar(")")) throw "function parameters not closed: " + this.s;
        }

        return function(scope, prev) {
            var that = this;
//            console.log("~ fun.exec", this, fun, scope, prev, params);
            return scope[fun].apply(this, params.map(function(param, i) { return param(scope, undefined); }));
        }
    }
};

Expression.prototype.parseFilter = function() {
    var match = /^ *\| ?(\w+)/.exec(this.s);
    if (match) {
        this.s = this.s.substr(match[0].length);
        var filter = this.filters[match[1]];
        if (!filter) throw 'Filter "' + match[1] + '" doesn\'t exist.';
        var params = [undefined];
        // additional params?
        if (this.isChar("(")) {
            params.push(this.parseExpression());
            while (this.isChar(",")) params.push(this.parseExpression());
            if (!this.isChar(")")) throw "filter parameters not closed: " + this.s;
        }
        return function(value) {
            params[0] = value;
            var scope = this;
            return filter.apply(this, params.map(function(param, i) { return i ? param(scope, undefined) : param; }));
        }
    }
};

Expression.prototype.filters = {
    upper: function(value) {
        return value.toUpperCase();
    },
    lower: function(value) {
        return value.toLowerCase();
    },
    arg: function(value, arg) {
//        console.log("~ [arg]", value, arguments);
        return value.replace(/\$/, arg);
    },
    date: function(value) {
        var format = {
            fullDate: "EEEE, MMMM d,y"
        }[value] || value;
        return Date(value).toString("EEEE, MMMM d,y");
    }
};

var data = {
    name: "Joe",
    user: {
        name: "John Doe"
    },
    fun: function(arg) { return "["+arg+"]";},
    time: function() {
        if (this.update) setInterval(this.update, 3000);
        return +new Date();
    }
};

function execute(expr, data) {
    var e = new Expression(expr);
    var value = e(data, function(value) {
        console.log("~ execute.onUpdate:", '"' + expr + '"'," ==> ", value);
    });
    console.log("~ execute:", '"' + expr + '"',"==>", value, "- Bindings:", e.bindings);
}

execute("42", data);
//execute("user.name | arg(name)", data);
//execute("'user.name'", data);
//execute('"Hello $ and $!" | upper | arg(name) | arg(user.name, 42, fun("42"))', data);
//execute('fun(fun("poohh")) | upper', data);
execute('time() | date("fullDate")', data);
</script>
</html>
