<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/javascript" src="../js/gaia.js"></script>
    <script type="text/javascript" src="../js/decl.js"></script>
    <script type="text/javascript" src="data.js"></script>
    <link rel="stylesheet" href="list.css">
    <title>compile me, link me, be happy!</title>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700,600,300' rel='stylesheet' type='text/css'>
    <style>
        body, input {
            font-family: 'Open Sans', sans-serif;
        }
        *[template],
        *[repeat] {
            display: none !important;
            opacity: .33;
        }
        h2 {
            margin: 16px 0 8px 0;
            border-bottom: 2px solid #888;
            background: #DDD;
        }
        h3 {
            font-size: 1em;
            margin: 1em 0 .3em 0;
        }
        div.demo {
            background: #ECECEC;
            padding: 20px;
            border: 1px solid #CCC;
            box-shadow: 2px 2px 5px rgba(88, 88, 88, 0.2);
        }
        div.demo input {
            border: 1px solid #BDBDBD;
            border-radius: 2px;
            -webkit-box-shadow: inset 0px 2px 2px #ECECEC,0px 1px 1px white;
            -moz-box-shadow: inset 0px 2px 2px #ececec,0px 1px 1px #fff;
            box-shadow: inset 0px 2px 2px #ECECEC,0px 1px 1px white;
            background-color: white;
            padding: 5px 5px 5px 10px;
            outline: none;
            -webkit-transition: border linear 0.3s, box-shadow linear 0.3s;
            -moz-transition: border linear 0.2s, box-shadow linear 0.2s;
            -ms-transition: border linear 0.2s, box-shadow linear 0.2s;
            -o-transition: border linear 0.2s, box-shadow linear 0.2s;
            transition: border linear 0.3s, box-shadow linear 0.3s;
        }
        div.demo input:focus {
            border: 1px solid #4078C7;
            -w_ebkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6);
            -m_oz-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(82, 168, 236, 0.6);
            box-shadow: 0 0 8px rgba(82, 168, 236, 0.6);
            outline: none;
        }
    </style>
</head>
<body decl2>

    <h2>DOM traversing: {{ document.title }}</h2>
    <ul>
        <li>Current URL: {{ document.URL }}</li>
    </ul>

    <ul class="list">
        <li repeat="city in foo.cities">
            <div class="icon" style="background-image: url(images/{{city.type}}.png)"></div>
            <span class="name">City #{{city.country}}</span>
            <span class="desc"><b>{{city.tags.length}}</b> Tags: <a class="tag" repeat="tag in city.tags" href="/tags/{{ tag }}">{{ tag }}</a></span>
            <span class="dist">{{city.distance}} mi</span>
        </li>
    </ul>
    <div>Credits goes to: {{ ['Foo', 'Bar', 'Nix'] | join(" / ") }}, current time: {{ time() | date }}</div>

    <h3>Example</h3>
    <div class="demo">
        <input $model="input" onkeyup="first = this.value" placeholder="first name">
        <input onkeyup="last = this.value" placeholder="last name">
        <input type="number" onchange="age = this.value" placeholder="age"><br>
        <tt>First name | upper: {{ first | upper }}</tt><br>
        <tt>Last name | lower: {{ last | lower }}</tt><br>
        <tt>Age: {{ age }}</tt><br>
        <tt>joined: {{ [first, last, age]}}</tt><br>
    </div>

    <p>last modified: {{ document.lastModified }}</p>
</body>
<script>
    window.time = function() {
        if (gaia.$$update) setInterval(gaia.$$update, 1000);
        return new Date();
    };

    var foo = {
        cities: cities
    }
</script>
<script>
var modules = [];

// prevents SCRIPT traverse
modules.push(function(node, next) {
    if ("SCRIPT" === node.nodeName) {
        return;
    }
    next();
});

// proceed repeat
modules.push(function(node, next) {
    if (node.hasAttribute("repeat")) {
        var match = node.getAttribute("repeat").match(/^(\w*) in (.*)$/);
//        console.log("~ [repeat]", match);

        if (!match || match.length !== 3) {
            throw new Error("repeat needs 'x in y'");
        }

        // replace node to have a reference node in linking process.
        node.parentNode.insertBefore(document.createElement('span'), node);
        node.parentNode.removeChild(node);
        node.removeAttribute("repeat");

        var iterator = match[1]
          , collectionExpr = new Expression(match[2])
          , linker = compile(node)
          ;

//        dataSet = decl._prepareArray(dataSet);

        return function(n, next) {
            var scope = this;

            // extract and remove parentNode
            var parentNode = n.parentNode
              , instances = []
              , instance
              ;
            parentNode.removeChild(n);

            collectionExpr(scope, function(collection) {
                collection = decl._prepareArray(collection);
                console.log("~ collection eval:", collectionExpr.$source, "=", collection);

                // remove old instances
                while ((instance = instances.shift())) {
                    parentNode.removeChild(instance);
                }

                // create new instances
                for (var i = 0, l = collection.length; i < l; i++) {
                    var clone = node.cloneNode(true);
                    var cloneScope = decl.scope(scope);
                    cloneScope[iterator] = collection[i];
                    linker(clone, cloneScope);
                    parentNode.appendChild(clone);
                    instances.push(clone);
                }

                collection.$on("add", function(item) {
                    var clone = node.cloneNode(true);
                    var cloneScope = decl.scope(scope);
                    cloneScope[iterator] = item;
                    linker(clone, cloneScope);
                    parentNode.appendChild(clone);
                });

                collection.$on("remove", function(item, idx) {
                    var node = parentNode.children[idx];
                    parentNode.removeChild(node);
                });
            });
            next(scope); // linking
        };
    } else {
        next(); // compiling
    }
});

// Scope feature
modules.push(function(node, next) {
    if (node.hasAttribute("scope")) {
        var expr = new Expression(node.getAttribute("scope"));
        node.removeAttribute("scope");
        console.log("~ [scope]", expr.$source);
        next(function(node, next) {
            var scope = expr(this);
            if ("function" === typeof scope) {
                scope = new scope(this);
                console.log("Creating scope from function", scope);
            }
            console.log("~ scope.linking", scope);
            next(scope);
        });
    } else {
        next();
    }
});


/*
// fill #test nodes
modules.push(function(node, next) {
    next();
    if (1 === node.nodeType && "SPAN" === node.nodeName) {
        return function(node) {
            node.innerText = "*" + node.innerText + "*";
        };
    }
});
*/
// proceed {{ expressions }}
modules.push(function(node, next) {
    function decode(str) {
         return str && unescape(str.replace(/\+/g, " "));
    }
    if (0 === node.children.length) {
        var rx = /{{(.*?)}}/g
          , text = node.innerText
          , isText = undefined !== text && rx.test(text)
          , textPieces = undefined !== text && text.split(rx).map(function(piece, i) { return i%2 ? new Expression(piece) : piece })
          , href = node.href && decode(node.href)
          , isHref = undefined !== href && rx.test(href)
          , style = node.style.cssText && decode(node.style.cssText)
          , proceedStyle = undefined !== style && rx.test(style)
          ;

        if (isText || isHref || proceedStyle) {
            return function(node, next) {
                var scope = this;
                if (isText) {
                    var text = textPieces.slice();
                    textPieces.forEach(function(piece, i) {
                        if (piece instanceof Function) piece(scope, function(value) {
//                            console.log("~ update", value, i);
                            text[i] = value;
                            node.innerHTML = text.join("");
                        });
                    });
//                    node.innerHTML = textPieces.map(function(piece) { return piece instanceof Function ? piece(scope) : piece }).join("");
//                    node.innerHTML = text.replace(rx, function(all, match) {
//                        return "<i>" + decl.solve(scope, match.trim()) + "</i>";
//                    });
                }
                if (isHref) {
                    node.href = href.replace(rx, function(all, match) {
                        return decl.solve(scope, match.trim());
                    });
                }
                if (proceedStyle) {
                    node.style.cssText = style.replace(rx, function(all, match) {
                        return decl.solve(scope, match.trim());
                    });
                }
                next(scope);
            };
        }
    } else {
        next();
    }
});

// traverser
function traverser(node) {
    var nodes = []
      , l
      , links = []
      ;
    for (var i = node.children.length >>> 0; i--;) nodes[i] = node.children[i];
    for (i = 0; (node = nodes[i]); i++ ) {
        if (l = __compile(node)) {
            links.push([i, l]);
        }
    }
    return links.length && function(node, next) {
        var i = 0
          , link
          ;
        function f(scope) {
            if ((link = links[i++])) {
                link[1].call(scope, node.children[link[0]], f);
            }
        }
        f(this);
        next(this);
    };
};

function __compile(node) {
    var i = 0
      , module
      , fun
      , links = []
      ;

    function f() {
        if ((module = modules[i++])) {
            fun = module(node, function(fun) {
                if (fun) links.push(fun);
                f();
            });
            if (fun) links.push(fun);
        } else {
            fun = traverser(node);
            if (fun) links.push(fun);
        }
    }
    f();

    return links.length && function(node, next) {
        var i = 0
          , link
          ;
        function f(scope) {
            if ((link = links[i++])) {
                link.call(scope, node, f);
            }
        }
        f(this);
        next(this);
    };
}

function compile(node) {
    console.time('compile', "fooo");
//    console.log("~ compile", node);

    var linker = __compile(node);

    console.timeEnd('compile', "bar");

    // link function
    return function(node, scope) {
        scope = scope || window;
        linker.call(scope, node, function() {});
    };
};

compile(document.body)(document.body);
</script>
</html>
